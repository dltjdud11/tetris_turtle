<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëª¨ë°”ì¼ í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„ (ìµœì¢…)</title>
    
    <style>
        /* ê¸°ë³¸ ë ˆì´ì•„ì›ƒ ë° ìŠ¤íƒ€ì¼ (ì´ì „ ë²„ì „ê³¼ ìœ ì‚¬í•˜ë‚˜ ìµœì í™”) */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            background-color: #333;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden; 
            user-select: none;
            box-sizing: border-box;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: #222;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #game-board {
            display: grid;
            grid-template-rows: repeat(20, 1fr); 
            grid-template-columns: repeat(10, 1fr);
            width: 300px; 
            height: 600px;
            border: 3px solid #ccc;
            background-color: #111;
        }

        .cell {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 1px solid #000;
        }

        /* í…ŒíŠ¸ë¡œë¯¸ë…¸ ë¸”ë¡ ìƒ‰ìƒ */
        .T { background-color: purple; border-color: #6a0080; }
        .L { background-color: orange; border-color: #cc6600; }
        .J { background-color: blue; border-color: #000080; }
        .S { background-color: green; border-color: #004d00; }
        .Z { background-color: red; border-color: #800000; }
        .I { background-color: cyan; border-color: #008080; }
        .O { background-color: yellow; border-color: #808000; }

        .info-panel {
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.2em;
        }
        
        #start-button {
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ë§ */
        .controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 15px 0;
        }

        .controls button {
            padding: 15px 25px;
            font-size: 24px;
            background-color: #444;
            color: white;
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
            touch-action: manipulation; 
            flex-grow: 1; 
            margin: 0 5px;
            min-width: 60px;
            height: 60px;
        }

        /* ëª¨ë°”ì¼ í™”ë©´ ìµœì í™” */
        @media (max-width: 600px) {
            #game-board, .info-panel {
                width: 90vw; 
                max-width: 300px;
            }
            #game-board {
                height: calc(90vw * 2); 
                max-height: 600px;
            }
            .controls {
                width: 90vw;
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="info-panel">
            <p>SCORE: <span id="score">0</span></p>
            <button id="start-button">START</button>
        </div>
        
        <div id="game-board">
            </div>
        
        <div class="controls">
            <button id="left">â¬…ï¸</button>
            <button id="rotate">ğŸ”„</button>
            <button id="right">â¡ï¸</button>
            <button id="down">â¬‡ï¸</button>
        </div>
    </div>
    
    <script>
        // --- ê²Œì„ ì„¤ì • ---
        const COLS = 10;
        const ROWS = 20;
        let score = 0;
        let gameBoard = []; // DOM ì…€ ìš”ì†Œ ì €ì¥
        let gridState = Array(COLS * ROWS).fill(null); // ê° ì…€ì˜ ìƒíƒœ(null ë˜ëŠ” ë¸”ë¡ ì´ë¦„) ì €ì¥
        
        let currentTetromino;
        let currentTetrominoName;
        let currentRotation = 0;
        let currentPosition = 4;
        let timerId = null;

        const boardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const startButton = document.getElementById('start-button');
        const controls = {
            left: document.getElementById('left'),
            rotate: document.getElementById('rotate'),
            right: document.getElementById('right'),
            down: document.getElementById('down'),
        };

        // --- í…ŒíŠ¸ë¡œë¯¸ë…¸ ëª¨ì–‘ ì •ì˜ (ì´ì „ê³¼ ë™ì¼) ---
        const TETROMINOS = [
            [[1, COLS + 1, COLS * 2 + 1, 2], [COLS, COLS * 2, COLS * 2 + 1, COLS * 2 + 2], [1, COLS + 1, COLS * 2 + 1, COLS * 2], [COLS, COLS + 1, COLS + 2, COLS * 2 + 2]], // L
            [[1, COLS + 1, COLS * 2 + 1, 0], [COLS, COLS * 2, COLS + 1, COLS + 2], [1, COLS + 1, COLS * 2 + 1, COLS * 2 + 2], [COLS + 2, COLS * 2, COLS * 2 + 1, COLS * 2 + 2]], // J
            [[1, COLS, COLS + 1, COLS + 2], [1, COLS + 1, COLS * 2 + 1, COLS + 2], [COLS, COLS + 1, COLS + 2, COLS * 2 + 1], [1, COLS, COLS + 1, COLS * 2 + 1]], // T
            [[COLS + 1, COLS + 2, COLS * 2, COLS * 2 + 1], [0, COLS, COLS + 1, COLS * 2 + 1]], // S
            [[COLS, COLS + 1, COLS * 2 + 1, COLS * 2 + 2], [1, COLS, COLS + 1, COLS * 2]], // Z
            [[1, COLS + 1, COLS * 2 + 1, COLS * 3 + 1], [COLS, COLS + 1, COLS + 2, COLS + 3], [1, COLS + 1, COLS * 2 + 1, COLS * 3 + 1], [COLS, COLS + 1, COLS + 2, COLS + 3]], // I (4íšŒì „ ì •ì˜)
            [[0, 1, COLS, COLS + 1]] // O
        ];
        const TETROMINO_NAMES = ['L', 'J', 'T', 'S', 'Z', 'I', 'O'];

        // --- ë³´ë“œ ì´ˆê¸°í™” ---
        function createBoard() {
            boardElement.innerHTML = '';
            gameBoard = [];
            gridState = Array(COLS * ROWS).fill(null);
            for (let i = 0; i < COLS * ROWS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                boardElement.appendChild(cell);
                gameBoard.push(cell); 
            }
        }

        // --- ë¸”ë¡ ìƒì„± ---
        function generateTetromino() {
            const randomIndex = Math.floor(Math.random() * TETROMINOS.length);
            currentTetromino = TETROMINOS[randomIndex];
            currentTetrominoName = TETROMINO_NAMES[randomIndex];
            currentRotation = 0;
            currentPosition = 4; // ìƒë‹¨ ì¤‘ì•™ ì‹œì‘

            if (checkCollision(currentPosition)) {
                gameOver();
                return false;
            }
            draw();
            return true;
        }

        // --- ë¸”ë¡ ê·¸ë¦¬ê¸°/ì§€ìš°ê¸° ---
        function draw() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (gameBoard[targetIndex]) {
                    gameBoard[targetIndex].classList.add(currentTetrominoName);
                }
            });
        }

        function undraw() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (gameBoard[targetIndex]) {
                    gameBoard[targetIndex].classList.remove(currentTetrominoName);
                }
            });
        }

        // --- ì¶©ëŒ ê°ì§€ (ê°€ì¥ ì¤‘ìš”í•œ í•¨ìˆ˜) ---
        function checkCollision(nextPosition, nextRotation = currentRotation) {
            return currentTetromino[nextRotation].some(index => {
                const targetIndex = nextPosition + index;
                const row = Math.floor(targetIndex / COLS);
                const col = targetIndex % COLS;
                const currentRow = Math.floor((currentPosition + index) / COLS);
                
                // 1. ë³´ë“œ ë°”ë‹¥ì„ ë„˜ì—ˆëŠ”ì§€
                if (targetIndex >= COLS * ROWS) return true;
                
                // 2. ì´ë¯¸ ê³ ì •ëœ ë¸”ë¡ì— ì¶©ëŒí•˜ëŠ”ì§€ (nullì´ ì•„ë‹ˆë©´ ê³ ì •ëœ ë¸”ë¡)
                if (gridState[targetIndex] !== null) return true;

                // 3. ë²½ ì¶©ëŒ (ì¢Œ/ìš°)
                // í˜„ì¬ ì¤„ì—ì„œ ë‹¤ìŒ ì¤„ë¡œ ì´ë™í•˜ì§€ ì•ŠëŠ”ë°, ì—´ ìœ„ì¹˜ê°€ 0(ì™¼ìª½ ë) ë˜ëŠ” 9(ì˜¤ë¥¸ìª½ ë)ë¥¼ ë„˜ìœ¼ë ¤ê³  í•  ë•Œ
                if (row !== currentRow) {
                    // ì™¼ìª½ ê²½ê³„ ì´ë™ ì²´í¬: ì™¼ìª½ìœ¼ë¡œ ì´ë™ ì‹œ ì™¼ìª½ ëì„ ë„˜ëŠ” ê²½ìš°
                    if (targetIndex % COLS === COLS - 1 && nextPosition < currentPosition) return true; 
                    // ì˜¤ë¥¸ìª½ ê²½ê³„ ì´ë™ ì²´í¬: ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™ ì‹œ ì˜¤ë¥¸ìª½ ëì„ ë„˜ëŠ” ê²½ìš°
                    if (targetIndex % COLS === 0 && nextPosition > currentPosition) return true;
                }
                
                return false;
            });
        }
        
        // --- ë¸”ë¡ ì´ë™ ë¡œì§ ---
        function move(direction) {
            if (!timerId) return;
            undraw();
            let newPosition = currentPosition + direction;

            // ì¢Œìš° ë²½ ì¶©ëŒ ë°©ì§€ (ì •í™•í•œ êµ¬í˜„)
            const isAtLeftEdge = currentTetromino[currentRotation].some(index => (currentPosition + index) % COLS === 0) && direction === -1;
            const isAtRightEdge = currentTetromino[currentRotation].some(index => (currentPosition + index) % COLS === COLS - 1) && direction === 1;

            if (isAtLeftEdge || isAtRightEdge) {
                newPosition = currentPosition;
            }

            if (!checkCollision(newPosition)) {
                currentPosition = newPosition;
            }
            draw();
        }

        // --- ë¸”ë¡ íšŒì „ ë¡œì§ ---
        function rotate() {
            if (!timerId) return;
            undraw();
            const nextRotation = (currentRotation + 1) % currentTetromino.length;

            if (!checkCollision(currentPosition, nextRotation)) {
                currentRotation = nextRotation;
            }
            draw();
        }

        // --- ë¸”ë¡ í•˜ê°• ë¡œì§ ---
        function fall() {
            undraw();
            let newPosition = currentPosition + COLS;

            if (checkCollision(newPosition)) {
                // ì¶©ëŒí•˜ë©´ ë¸”ë¡ ê³ ì •
                freeze();
                checkLines();
                generateTetromino(); // ìƒˆ ë¸”ë¡ ìƒì„±
            } else {
                currentPosition = newPosition;
            }
            draw();
        }

        // --- ë¸”ë¡ ê³ ì • ---
        function freeze() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (targetIndex >= 0 && targetIndex < COLS * ROWS) {
                    // gridState ë°°ì—´ì— ë¸”ë¡ ìƒíƒœ ì˜êµ¬ ì €ì¥
                    gridState[targetIndex] = currentTetrominoName;
                }
            });
        }

        // --- ì¤„ ì œê±° ë° ì ìˆ˜ ê³„ì‚° (ì•ˆì •í™”ëœ ë¡œì§) ---
        function checkLines() {
            let linesCleared = 0;
            
            for (let i = ROWS - 1; i >= 0; i--) {
                const rowStart = i * COLS;
                const rowEnd = rowStart + COLS;
                const rowState = gridState.slice(rowStart, rowEnd);
                
                // í•´ë‹¹ ì¤„ì´ nullì´ ì•„ë‹Œ ìš”ì†Œ(ì¦‰, ë¸”ë¡)ë¡œë§Œ ì±„ì›Œì ¸ ìˆëŠ”ì§€ í™•ì¸
                const isFull = rowState.every(cellState => cellState !== null);
                
                if (isFull) {
                    linesCleared++;
                    
                    // 1. DOMì—ì„œ í•´ë‹¹ ì¤„ì˜ ë¸”ë¡ í´ë˜ìŠ¤ ì œê±°
                    for (let j = rowStart; j < rowEnd; j++) {
                        gameBoard[j].className = 'cell';
                    }

                    // 2. gridState ë°°ì—´ì—ì„œ í•´ë‹¹ ì¤„ì„ ì œê±°í•˜ê³ , ë§¨ ì•ì— ìƒˆ ë¹ˆ ì¤„(null)ì„ ì‚½ì…
                    gridState.splice(rowStart, COLS);
                    const emptyRow = Array(COLS).fill(null);
                    gridState.unshift(...emptyRow);
                }
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100;
                scoreElement.textContent = score;

                // 3. gridStateì˜ ë³€ê²½ ì‚¬í•­ì„ DOMì— ë°˜ì˜ (ì „ì²´ ë¦¬ë Œë”ë§)
                updateDOM();
            }
        }

        // --- DOM ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì¤„ ì œê±° í›„ ìƒíƒœ ë°˜ì˜) ---
        function updateDOM() {
            for (let i = 0; i < COLS * ROWS; i++) {
                gameBoard[i].className = 'cell'; // ê¸°ë³¸ ì´ˆê¸°í™”
                if (gridState[i] !== null) {
                    // gridStateì— ì €ì¥ëœ ë¸”ë¡ ì´ë¦„ìœ¼ë¡œ í´ë˜ìŠ¤ ì¶”ê°€
                    gameBoard[i].classList.add(gridState[i]);
                }
            }
        }

        // --- ê²Œì„ ì˜¤ë²„ ---
        function gameOver() {
            clearInterval(timerId);
            timerId = null;
            startButton.textContent = 'RESTART';
            alert(`Game Over! Score: ${score}`);
        }

        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

        // PC í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            if (!timerId) return; 

            if (e.key === 'ArrowLeft') move(-1);
            else if (e.key === 'ArrowRight') move(1);
            else if (e.key === 'ArrowDown') fall();
            else if (e.key === 'ArrowUp') rotate();
        });

        // ëª¨ë°”ì¼/í„°ì¹˜ ë²„íŠ¼ ì´ë²¤íŠ¸ (touchstart ì‚¬ìš©: ë” ë¹ ë¥¸ ë°˜ì‘)
        controls.left.addEventListener('touchstart', (e) => { e.preventDefault(); move(-1); });
        controls.right.addEventListener('touchstart', (e) => { e.preventDefault(); move(1); });
        controls.down.addEventListener('touchstart', (e) => { e.preventDefault(); fall(); });
        controls.rotate.addEventListener('touchstart', (e) => { e.preventDefault(); rotate(); });


        // ê²Œì„ ì‹œì‘/ì¼ì‹œì •ì§€ ë²„íŠ¼
        startButton.addEventListener('click', () => {
            if (timerId) {
                // ì¼ì‹œ ì •ì§€
                clearInterval(timerId);
                timerId = null;
                startButton.textContent = 'RESUME';
            } else {
                if (startButton.textContent === 'START' || startButton.textContent === 'RESTART') {
                    // ìƒˆ ê²Œì„ ì‹œì‘
                    createBoard(); // ë³´ë“œ ì´ˆê¸°í™” ë° DOM ìƒì„±
                    score = 0;
                    scoreElement.textContent = score;
                    generateTetromino();
                }
                
                // ê²Œì„ ì¬ê°œ ë˜ëŠ” ì‹œì‘
                timerId = setInterval(fall, 800); // í•˜ê°• ì†ë„: 0.8ì´ˆ
                startButton.textContent = 'PAUSE';
            }
        });

        // --- ì´ˆê¸° ì‹¤í–‰ ---
        createBoard();
    </script>
</body>
</html>
